#define GL_SILENCE_DEPRECATION

#include <iomanip>
#include <iostream>
#include <cmath>
#include <GLFW/glfw3.h>

#include "Aster/graphics/2d_graphics.h"
#include "Aster/graphics/inferno_scale.h"
#include "Aster/graphics/animations.h"

#include "Aster/simulations/BHT_sim.h"
#include "Aster/simulations/barnes-hut.h"

namespace Aster{
    
void render(Simulation* s){
    auto r = Renderer::Renderer2d(s);
    r.run();
}

namespace Renderer{

std::vector<std::vector<float>> inferno_cm = {
	{0x00/255, 0x00/255, 0x03/255},
	{0x00/255, 0x00/255, 0x04/255},
	{0x00/255, 0x00/255, 0x06/255},
	{0x01/255, 0x00/255, 0x07/255},
	{0x01/255, 0x01/255, 0x09/255},
	{0x01/255, 0x01/255, 0x0b/255},
	{0x02/255, 0x01/255, 0x0e/255},
	{0x02/255, 0x02/255, 0x10/255},
	{0x03/255, 0x02/255, 0x12/255},
	{0x04/255, 0x03/255, 0x14/255},
	{0x04/255, 0x03/255, 0x16/255},
	{0x05/255, 0x04/255, 0x18/255},
	{0x06/255, 0x04/255, 0x1b/255},
	{0x07/255, 0x05/255, 0x1d/255},
	{0x08/255, 0x06/255, 0x1f/255},
	{0x09/255, 0x06/255, 0x21/255},
	{0x0a/255, 0x07/255, 0x24/255},
	{0x0c/255, 0x07/255, 0x26/255},
	{0x0d/255, 0x08/255, 0x28/255},
	{0x0e/255, 0x08/255, 0x2b/255},
	{0x0f/255, 0x09/255, 0x2d/255},
	{0x10/255, 0x09/255, 0x2f/255},
	{0x12/255, 0x0a/255, 0x32/255},
	{0x13/255, 0x0a/255, 0x34/255},
	{0x14/255, 0x0b/255, 0x37/255},
	{0x16/255, 0x0b/255, 0x39/255},
	{0x17/255, 0x0b/255, 0x3b/255},
	{0x19/255, 0x0b/255, 0x3e/255},
	{0x1a/255, 0x0c/255, 0x40/255},
	{0x1c/255, 0x0c/255, 0x43/255},
	{0x1d/255, 0x0c/255, 0x45/255},
	{0x1f/255, 0x0c/255, 0x48/255},
	{0x21/255, 0x0c/255, 0x4a/255},
	{0x22/255, 0x0b/255, 0x4c/255},
	{0x24/255, 0x0b/255, 0x4e/255},
	{0x26/255, 0x0b/255, 0x51/255},
	{0x27/255, 0x0b/255, 0x53/255},
	{0x29/255, 0x0b/255, 0x55/255},
	{0x2b/255, 0x0a/255, 0x57/255},
	{0x2d/255, 0x0a/255, 0x59/255},
	{0x2e/255, 0x0a/255, 0x5a/255},
	{0x30/255, 0x0a/255, 0x5c/255},
	{0x32/255, 0x09/255, 0x5e/255},
	{0x34/255, 0x09/255, 0x5f/255},
	{0x36/255, 0x09/255, 0x60/255},
	{0x37/255, 0x09/255, 0x62/255},
	{0x39/255, 0x09/255, 0x63/255},
	{0x3b/255, 0x09/255, 0x64/255},
	{0x3c/255, 0x09/255, 0x65/255},
	{0x3e/255, 0x09/255, 0x66/255},
	{0x40/255, 0x09/255, 0x67/255},
	{0x42/255, 0x09/255, 0x68/255},
	{0x43/255, 0x0a/255, 0x68/255},
	{0x45/255, 0x0a/255, 0x69/255},
	{0x47/255, 0x0a/255, 0x6a/255},
	{0x48/255, 0x0b/255, 0x6a/255},
	{0x4a/255, 0x0b/255, 0x6b/255},
	{0x4c/255, 0x0c/255, 0x6b/255},
	{0x4d/255, 0x0c/255, 0x6c/255},
	{0x4f/255, 0x0d/255, 0x6c/255},
	{0x50/255, 0x0d/255, 0x6c/255},
	{0x52/255, 0x0e/255, 0x6d/255},
	{0x54/255, 0x0e/255, 0x6d/255},
	{0x55/255, 0x0f/255, 0x6d/255},
	{0x57/255, 0x0f/255, 0x6d/255},
	{0x59/255, 0x10/255, 0x6e/255},
	{0x5a/255, 0x11/255, 0x6e/255},
	{0x5c/255, 0x11/255, 0x6e/255},
	{0x5d/255, 0x12/255, 0x6e/255},
	{0x5f/255, 0x12/255, 0x6e/255},
	{0x61/255, 0x13/255, 0x6e/255},
	{0x62/255, 0x14/255, 0x6e/255},
	{0x64/255, 0x14/255, 0x6e/255},
	{0x65/255, 0x15/255, 0x6e/255},
	{0x67/255, 0x15/255, 0x6e/255},
	{0x68/255, 0x16/255, 0x6e/255},
	{0x6a/255, 0x17/255, 0x6e/255},
	{0x6c/255, 0x17/255, 0x6e/255},
	{0x6d/255, 0x18/255, 0x6e/255},
	{0x6f/255, 0x18/255, 0x6e/255},
	{0x70/255, 0x19/255, 0x6e/255},
	{0x72/255, 0x1a/255, 0x6e/255},
	{0x74/255, 0x1a/255, 0x6e/255},
	{0x75/255, 0x1b/255, 0x6e/255},
	{0x77/255, 0x1b/255, 0x6d/255},
	{0x78/255, 0x1c/255, 0x6d/255},
	{0x7a/255, 0x1c/255, 0x6d/255},
	{0x7c/255, 0x1d/255, 0x6d/255},
	{0x7d/255, 0x1d/255, 0x6c/255},
	{0x7f/255, 0x1e/255, 0x6c/255},
	{0x80/255, 0x1f/255, 0x6c/255},
	{0x82/255, 0x1f/255, 0x6c/255},
	{0x84/255, 0x20/255, 0x6b/255},
	{0x85/255, 0x20/255, 0x6b/255},
	{0x87/255, 0x21/255, 0x6b/255},
	{0x88/255, 0x21/255, 0x6a/255},
	{0x8a/255, 0x22/255, 0x6a/255},
	{0x8c/255, 0x23/255, 0x69/255},
	{0x8d/255, 0x23/255, 0x69/255},
	{0x8f/255, 0x24/255, 0x68/255},
	{0x90/255, 0x24/255, 0x68/255},
	{0x92/255, 0x25/255, 0x68/255},
	{0x94/255, 0x25/255, 0x67/255},
	{0x95/255, 0x26/255, 0x67/255},
	{0x97/255, 0x27/255, 0x66/255},
	{0x98/255, 0x27/255, 0x65/255},
	{0x9a/255, 0x28/255, 0x65/255},
	{0x9b/255, 0x28/255, 0x64/255},
	{0x9d/255, 0x29/255, 0x64/255},
	{0x9f/255, 0x2a/255, 0x63/255},
	{0xa0/255, 0x2a/255, 0x62/255},
	{0xa2/255, 0x2b/255, 0x62/255},
	{0xa3/255, 0x2b/255, 0x61/255},
	{0xa5/255, 0x2c/255, 0x60/255},
	{0xa7/255, 0x2d/255, 0x60/255},
	{0xa8/255, 0x2d/255, 0x5f/255},
	{0xaa/255, 0x2e/255, 0x5e/255},
	{0xab/255, 0x2f/255, 0x5d/255},
	{0xad/255, 0x2f/255, 0x5d/255},
	{0xae/255, 0x30/255, 0x5c/255},
	{0xb0/255, 0x31/255, 0x5b/255},
	{0xb1/255, 0x31/255, 0x5a/255},
	{0xb3/255, 0x32/255, 0x59/255},
	{0xb4/255, 0x33/255, 0x59/255},
	{0xb6/255, 0x34/255, 0x58/255},
	{0xb7/255, 0x34/255, 0x57/255},
	{0xb9/255, 0x35/255, 0x56/255},
	{0xba/255, 0x36/255, 0x55/255},
	{0xbc/255, 0x37/255, 0x54/255},
	{0xbd/255, 0x38/255, 0x53/255},
	{0xbf/255, 0x38/255, 0x52/255},
	{0xc0/255, 0x39/255, 0x51/255},
	{0xc2/255, 0x3a/255, 0x50/255},
	{0xc3/255, 0x3b/255, 0x4f/255},
	{0xc5/255, 0x3c/255, 0x4e/255},
	{0xc6/255, 0x3d/255, 0x4d/255},
	{0xc7/255, 0x3e/255, 0x4c/255},
	{0xc9/255, 0x3f/255, 0x4b/255},
	{0xca/255, 0x40/255, 0x4a/255},
	{0xcb/255, 0x41/255, 0x49/255},
	{0xcd/255, 0x42/255, 0x48/255},
	{0xce/255, 0x43/255, 0x47/255},
	{0xcf/255, 0x44/255, 0x46/255},
	{0xd1/255, 0x45/255, 0x45/255},
	{0xd2/255, 0x46/255, 0x44/255},
	{0xd3/255, 0x47/255, 0x43/255},
	{0xd5/255, 0x48/255, 0x41/255},
	{0xd6/255, 0x49/255, 0x40/255},
	{0xd7/255, 0x4a/255, 0x3f/255},
	{0xd8/255, 0x4c/255, 0x3e/255},
	{0xd9/255, 0x4d/255, 0x3d/255},
	{0xdb/255, 0x4e/255, 0x3c/255},
	{0xdc/255, 0x4f/255, 0x3b/255},
	{0xdd/255, 0x51/255, 0x39/255},
	{0xde/255, 0x52/255, 0x38/255},
	{0xdf/255, 0x53/255, 0x37/255},
	{0xe0/255, 0x55/255, 0x36/255},
	{0xe1/255, 0x56/255, 0x35/255},
	{0xe2/255, 0x57/255, 0x33/255},
	{0xe3/255, 0x59/255, 0x32/255},
	{0xe4/255, 0x5a/255, 0x31/255},
	{0xe5/255, 0x5b/255, 0x30/255},
	{0xe6/255, 0x5d/255, 0x2f/255},
	{0xe7/255, 0x5e/255, 0x2d/255},
	{0xe8/255, 0x60/255, 0x2c/255},
	{0xe9/255, 0x61/255, 0x2b/255},
	{0xea/255, 0x63/255, 0x2a/255},
	{0xeb/255, 0x64/255, 0x28/255},
	{0xec/255, 0x66/255, 0x27/255},
	{0xed/255, 0x67/255, 0x26/255},
	{0xed/255, 0x69/255, 0x25/255},
	{0xee/255, 0x6a/255, 0x23/255},
	{0xef/255, 0x6c/255, 0x22/255},
	{0xf0/255, 0x6e/255, 0x21/255},
	{0xf1/255, 0x6f/255, 0x20/255},
	{0xf1/255, 0x71/255, 0x1e/255},
	{0xf2/255, 0x72/255, 0x1d/255},
	{0xf3/255, 0x74/255, 0x1c/255},
	{0xf3/255, 0x76/255, 0x1a/255},
	{0xf4/255, 0x77/255, 0x19/255},
	{0xf4/255, 0x79/255, 0x18/255},
	{0xf5/255, 0x7b/255, 0x16/255},
	{0xf6/255, 0x7d/255, 0x15/255},
	{0xf6/255, 0x7e/255, 0x14/255},
	{0xf7/255, 0x80/255, 0x12/255},
	{0xf7/255, 0x82/255, 0x11/255},
	{0xf8/255, 0x84/255, 0x10/255},
	{0xf8/255, 0x85/255, 0x0e/255},
	{0xf8/255, 0x87/255, 0x0d/255},
	{0xf9/255, 0x89/255, 0x0c/255},
	{0xf9/255, 0x8b/255, 0x0b/255},
	{0xfa/255, 0x8d/255, 0x09/255},
	{0xfa/255, 0x8e/255, 0x08/255},
	{0xfa/255, 0x90/255, 0x08/255},
	{0xfb/255, 0x92/255, 0x07/255},
	{0xfb/255, 0x94/255, 0x06/255},
	{0xfb/255, 0x96/255, 0x06/255},
	{0xfb/255, 0x98/255, 0x06/255},
	{0xfc/255, 0x99/255, 0x06/255},
	{0xfc/255, 0x9b/255, 0x06/255},
	{0xfc/255, 0x9d/255, 0x06/255},
	{0xfc/255, 0x9f/255, 0x07/255},
	{0xfc/255, 0xa1/255, 0x07/255},
	{0xfc/255, 0xa3/255, 0x08/255},
	{0xfc/255, 0xa5/255, 0x0a/255},
	{0xfc/255, 0xa7/255, 0x0b/255},
	{0xfc/255, 0xa9/255, 0x0d/255},
	{0xfc/255, 0xaa/255, 0x0e/255},
	{0xfc/255, 0xac/255, 0x10/255},
	{0xfc/255, 0xae/255, 0x12/255},
	{0xfc/255, 0xb0/255, 0x14/255},
	{0xfc/255, 0xb2/255, 0x16/255},
	{0xfc/255, 0xb4/255, 0x18/255},
	{0xfc/255, 0xb6/255, 0x1a/255},
	{0xfc/255, 0xb8/255, 0x1c/255},
	{0xfc/255, 0xba/255, 0x1e/255},
	{0xfb/255, 0xbc/255, 0x21/255},
	{0xfb/255, 0xbe/255, 0x23/255},
	{0xfb/255, 0xc0/255, 0x25/255},
	{0xfb/255, 0xc2/255, 0x28/255},
	{0xfa/255, 0xc4/255, 0x2a/255},
	{0xfa/255, 0xc6/255, 0x2d/255},
	{0xfa/255, 0xc8/255, 0x2f/255},
	{0xf9/255, 0xca/255, 0x32/255},
	{0xf9/255, 0xcc/255, 0x34/255},
	{0xf9/255, 0xce/255, 0x37/255},
	{0xf8/255, 0xd0/255, 0x3a/255},
	{0xf8/255, 0xd2/255, 0x3d/255},
	{0xf7/255, 0xd4/255, 0x3f/255},
	{0xf7/255, 0xd6/255, 0x42/255},
	{0xf6/255, 0xd8/255, 0x45/255},
	{0xf6/255, 0xd9/255, 0x49/255},
	{0xf5/255, 0xdb/255, 0x4c/255},
	{0xf5/255, 0xdd/255, 0x4f/255},
	{0xf4/255, 0xdf/255, 0x52/255},
	{0xf4/255, 0xe1/255, 0x56/255},
	{0xf4/255, 0xe3/255, 0x59/255},
	{0xf3/255, 0xe5/255, 0x5d/255},
	{0xf3/255, 0xe7/255, 0x61/255},
	{0xf2/255, 0xe9/255, 0x65/255},
	{0xf2/255, 0xea/255, 0x69/255},
	{0xf2/255, 0xec/255, 0x6d/255},
	{0xf2/255, 0xee/255, 0x71/255},
	{0xf2/255, 0xef/255, 0x75/255},
	{0xf2/255, 0xf1/255, 0x79/255},
	{0xf2/255, 0xf3/255, 0x7d/255},
	{0xf3/255, 0xf4/255, 0x82/255},
	{0xf3/255, 0xf5/255, 0x86/255},
	{0xf4/255, 0xf7/255, 0x8a/255},
	{0xf5/255, 0xf8/255, 0x8e/255},
	{0xf6/255, 0xf9/255, 0x92/255},
	{0xf7/255, 0xfb/255, 0x96/255},
	{0xf8/255, 0xfc/255, 0x9a/255},
	{0xf9/255, 0xfd/255, 0x9d/255},
	{0xfb/255, 0xfe/255, 0xa1/255},
	{0xfd/255, 0xfd/255, 0x00/255}
};

//===---------------------------------------------------------===//
// 2d rendering impl                                             //
//===---------------------------------------------------------===//

using render_func = void(*)(Simulation*);

Renderer2d::Renderer2d(Simulation* _s)  : _s(_s) {
    render = render_modes[_s -> data.type];

    if (!glfwInit()) 
        throw std::runtime_error("glfw failed to initialize");


    window = glfwCreateWindow(_s -> data.WIDTH, _s -> data.HEIGHT, "Aster's simulation", nullptr, nullptr);

    
    if (!window) {
        glfwTerminate();
        throw std::runtime_error("glfw failed to create window");
    }
}

void Renderer2d::framebuffer_size_callback(GLFWwindow* window, int width, int height) {
	void* ptr = glfwGetWindowUserPointer(window);
    auto* renderer = static_cast<Renderer2d*>(ptr);

    renderer -> current_width = width;
    renderer -> current_height = height;
    glViewport(0, 0, width, height);
}

void Renderer2d::run(){
    glfwMakeContextCurrent(window);
    bool paused = false;

	glfwSetWindowUserPointer(window, this);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	if (!_s -> has_loaded_yet()){
		std::thread t([this](){
			this -> _s -> load();
		});
		
		show_loadingbar(window, _s);
		t.join();
	}
	glfwDestroyWindow(window);

 	window = glfwCreateWindow(_s -> data.WIDTH, _s -> data.HEIGHT, "Aster's simulation", nullptr, nullptr);

    glfwMakeContextCurrent(window);
	glfwSetWindowUserPointer(window, this);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    while (!glfwWindowShouldClose(window)) {
        if (!paused) body_update_func(); 

        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
            paused = !paused;

		if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            break;


        (this ->* render)();

        glfwSwapBuffers(window); 
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();     
}

void Renderer2d::body_update_func(){
    _s -> step();
}
    
void Renderer2d::draw_termal(){
    glClearColor(0.f, 0.f, 0.f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POINTS);

    glPointSize(10);
    
    for (const auto& p : _s -> bodies){
        glColor3f(1.0, 1.0, 1.0);
        // if it's in the canva range it draws it  
        if (p.position.x >= 0 && p.position.x < _s -> data.WIDTH && p.position.y >= 0 && p.position.y < _s -> data.HEIGHT)
            glVertex2f(
                2.f * p.position.x / current_width - 1, 
                2.f * p.position.y / current_height - 1
            );
    }

    glEnd();
}

void Renderer2d::draw_minimal(){
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POINTS);

    glPointSize(10);
    
    for (const auto& p : _s -> bodies){
        glColor3f(1.0, 1.0, 1.0);
        // if it's in the canva range it draws it 
        if (p.position.x >= 0 && p.position.x < _s -> data.WIDTH && p.position.y >= 0 && p.position.y < _s -> data.HEIGHT)
            glVertex2f(
                2.f * p.position.x / current_width - 1, 
                2.f * p.position.y / current_height - 1
            );
    }

    glEnd();
}

void Renderer2d::draw_detailed(){
    glClear(GL_COLOR_BUFFER_BIT);
    glClearColor(0.f, 0.f, 0.f, 1.0f);
    glBegin(GL_POINTS);

    for (const auto& p : _s -> bodies){
        glColor3f(1.0, 0.0, 0.0);    
        glPointSize(std::log(p.mass)/10);  
        // if it's in the canva range it draws it 
        if (p.position.x >= 0 && p.position.x < _s -> data.WIDTH && p.position.y >= 0 && p.position.y < _s -> data.graph_height)
            glVertex2f(
                2.f * p.position.x / current_width - 1, 
                2.f * p.position.y / current_height - 1
            );
    }

    if (_s -> data.show_graph) {
        //clear_graph(_s);
        //draw_graph(_s);
    }

    glEnd();
}

//===---------------------------------------------------------===//
// text rendering                                                //
//===---------------------------------------------------------===//


/*
void clear_graph(Simulation* _s){
    for (int i = 0; i < _s -> data.WIDTH; i++){
    for (int j = _s -> data.graph_height; j < _s -> data.HEIGHT; j++){
        clients[_s].screen.setPixel(i, j, bg_color);
    }
    }
}

void draw_graph(Simulation* _s){
    std::ostringstream scien;
    scien << std::scientific << std::setprecision(3) << _s -> lagrangians.back();
    clients[_s].lagr_text.setString("Lagrangian: "+ scien.str() + "J");
    clients[_s].lagr_text.setPosition(10, _s -> data.graph_height + 10);
    clients[_s].window -> draw(clients[_s].lagr_text);

    for (int i = 0; i < _s -> data.WIDTH; ++i)
        clients[_s].screen.setPixel(i, _s -> data.graph_height, sf::Color::White);

    double p1, p2 = 0;
    int max_height = _s -> data.HEIGHT - _s -> data.graph_height;

    for (int index = 1; index < _s -> lagrangians.size(); index++){
        p2 = std::clamp(_s -> data.HEIGHT - _s -> lagrangians[index] * max_height / _s -> highest_lagrangian, 0.0, _s -> data.HEIGHT-1);
        p1 = std::clamp(_s -> data.HEIGHT - _s -> lagrangians[index-1] *  max_height / _s -> highest_lagrangian, 0.0, _s -> data.HEIGHT-1);

        //assert(p2 < HEIGHT);
        clients[_s].screen.setPixel(index, p2, sf::Color::White);

        int 
            start = (int)std::min(p1, p2),
            stop = (int)std::max(p1, p2)           
        ;

        for (int i = start; i < stop; i++){
            clients[_s].screen.setPixel(index, i, sf::Color::White);
        }

    }
}

void reset(Simulation* _s){
    clients[_s].screen = clients[_s].blank;
}

int clamp_rgb(double x){
    return (int)std::max(std::min(int(x), 255), 0);
}
*/
}
}