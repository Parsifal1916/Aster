#include <string>

namespace Aster{
namespace GPU{

inline std::string barnes_force_basic = 
"#define WG 256\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"double2 compute_force(double m1, double m2, double2 pos1, double2 pos2, double G) {\n"
"    double2 r = pos2 - pos1;\n"
"    double r_squared = r.x * r.x + r.y * r.y + 1e-10;\n"
"    double r_mag3 = r_squared * sqrt(r_squared);\n"
"    return (G * m1 * m2 / r_mag3) * r;\n"
"}\n"
"\n"
"__kernel void barnes_force(\n"
"    const uint    N,\n"
"    const double  G,\n"
"    const double  theta,\n"
"    const double  tree_size,\n"
"    const int     root_node,\n"
"    const int     max_nodes,\n"
"    __global const double*   node_masses,\n"
"    __global const double2*  pos,\n"
"    __global const double2*  com,\n"
"    __global const int*      lefts,\n"
"    __global const int*      rights,\n"
"    __global const double*   body_masses,\n"
"    __global       double2*  acc_out)\n"
"{\n"
"    int gid = get_global_id(0);\n"
"    if (gid >= N) return;\n"
"\n"
"    double2 my_pos = pos[gid];\n"
"    double  my_mass = body_masses[gid];\n"
"    double2 acc = (double2)(0.0, 0.0);\n"
"\n"
"    const int STACK_SIZE = 64;\n"
"    int  stack[STACK_SIZE];\n"
"    double sizes[STACK_SIZE];\n"
"    int sp = 0;\n"
"\n"
"    stack[sp] = root_node;\n"
"    sizes[sp] = tree_size;\n"
"\n"
"    while (sp >= 0) {\n"
"        int node = stack[sp];\n"
"        double size = sizes[sp];\n"
"        sp--;\n"
"\n"
"        if (node < 0 || node >= max_nodes) continue;\n"
"\n"
"        double2 r = my_pos - com[node];\n"
"        double d_squared = r.x * r.x + r.y * r.y + 1e-10;\n"
"\n"
"        bool is_leaf = (lefts[node] == -1 && rights[node] == -1);\n"
"\n"
"        if ((size * size / d_squared < theta * theta) || is_leaf) {\n"
"            if (d_squared > 0.0) {\n"
"                double2 f = compute_force(my_mass, node_masses[node], my_pos, com[node], G);\n"
"                acc += f / my_mass;\n"
"            }\n"
"            continue;\n"
"        }\n"
"\n"
"        if (rights[node] != -1 && sp+1 < STACK_SIZE) {\n"
"            sp++;\n"
"            stack[sp] = rights[node];\n"
"            sizes[sp] = size * 0.5;\n"
"        }\n"
"        if (lefts[node] != -1 && sp+1 < STACK_SIZE) {\n"
"            sp++;\n"
"            stack[sp] = lefts[node];\n"
"            sizes[sp] = size * 0.5;\n"
"        }\n"
"    }\n"
"\n"
"    acc_out[gid] = acc;\n"
"}\n";

inline std::string barnes_force_basic_3d = 
"#define WG 256\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"double3 compute_force(double m1, double m2, double3 pos1, double3 pos2, double G) {\n"
"    double3 r = pos2 - pos1;\n"
"    double r_squared = dot(r,r) + 1e-10;\n"
"    double r_mag3 = r_squared * sqrt(r_squared);\n"
"    return (G * m1 * m2 / r_mag3) * r;\n"
"}\n"
"\n"
"__kernel void barnes_force(\n"
"    const uint    N,\n"
"    const double  G,\n"
"    const double  theta,\n"
"    const double  tree_size,\n"
"    const int     root_node,\n"
"    const int     max_nodes,\n"
"    __global const double*   node_masses,\n"
"    __global const double*   pos,\n"
"    __global const double*   com,\n"
"    __global const int*      lefts,\n"
"    __global const int*      rights,\n"
"    __global const double*   body_masses,\n"
"    __global       double*  acc_out)\n"
"{\n"
"    int gid = get_global_id(0);\n"
"    if (gid >= N) return;\n"
"\n"
"    double3 my_pos = vload3(0, pos + 3*gid);\n"
"    double  my_mass = body_masses[gid];\n"
"    double3 acc = (double3)(0.0, 0.0, 0.0);\n"
"\n"
"    const int STACK_SIZE = 64;\n"
"    int  stack[STACK_SIZE];\n"
"    double sizes[STACK_SIZE];\n"
"    int sp = 0;\n"
"\n"
"    stack[sp] = root_node;\n"
"    sizes[sp] = tree_size;\n"
"\n"
"    while (sp >= 0) {\n"
"        int node = stack[sp];\n"
"        double size = sizes[sp];\n"
"        sp--;\n"
"\n"
"        if (node < 0 || node >= max_nodes) continue;\n"
"\n"
"        double3 nodepos = vload3(0, com + 3*node);\n"
"        double3 r = my_pos - nodepos;\n"
"        double d_squared = dot(r,r) + 1e-10;\n"
"\n"
"        bool is_leaf = (lefts[node] == -1 && rights[node] == -1);\n"
"\n"
"        if ((size * size / d_squared < theta) || is_leaf) {\n"
"            if (d_squared > 0.0) {\n"
"                double3 f = compute_force(my_mass, node_masses[node], my_pos, nodepos, G);\n"
"                acc += f / my_mass;\n"
"            }\n"
"            continue;\n"
"        }\n"
"\n"
"        if (rights[node] != -1 && sp+1 < STACK_SIZE) {\n"
"            sp++;\n"
"            stack[sp] = rights[node];\n"
"            sizes[sp] = size * 0.5;\n"
"        }\n"
"        if (lefts[node] != -1 && sp+1 < STACK_SIZE) {\n"
"            sp++;\n"
"            stack[sp] = lefts[node];\n"
"            sizes[sp] = size * 0.5;\n"
"        }\n"
"    }\n"
"\n"
"    vstore3(acc, 0, acc_out + 3*gid);;\n"
"}\n";

inline std::string barnes_force_basic_lite = 
"#define WG 256\n"
"\n"
"float2 compute_force(float m1, float m2, float2 pos1, float2 pos2, float G) {\n"
"    float2 r = pos2 - pos1;\n"
"    float r_squared = r.x * r.x + r.y * r.y + (float)1e-10;\n"
"    float r_mag = sqrt(r_squared);\n"
"    float force_mag = G * m1 * m2 / r_squared;\n"
"    return (force_mag / r_mag) * r;\n"
"}\n"
"\n"
"__kernel void barnes_force(\n"
"    const uint    N,\n"
"    const float  G,\n"
"    const float  theta,\n"
"    const float  tree_size,\n"
"    const int     root_node,\n"
"    const int     max_nodes,\n"
"    __global const float*   node_masses,\n"
"    __global const float2*  pos,\n"
"    __global const float2*  com,\n"
"    __global const int*      lefts,\n"
"    __global const int*      rights,\n"
"    __global const float*   body_masses,\n"
"    __global       float2*  acc_out)\n"
"{\n"
"    int gid = get_global_id(0);\n"
"    if (gid >= N) return;\n"
"\n"
"    float2 my_pos = pos[gid];\n"
"    float  my_mass = body_masses[gid];\n"
"    float2 acc = (float2)(0.0, 0.0);\n"
"\n"
"    const int STACK_SIZE = 64;\n"
"    int  stack[STACK_SIZE];\n"
"    float sizes[STACK_SIZE];\n"
"    int sp = 0;\n"
"\n"
"    stack[sp] = root_node;\n"
"    sizes[sp] = tree_size;\n"
"\n"
"    while (sp >= 0) {\n"
"        int node = stack[sp];\n"
"        float size = sizes[sp];\n"
"        sp--;\n"
"\n"
"        if (node < 0 || node >= max_nodes) continue;\n"
"\n"
"        float2 r = my_pos - com[node];\n"
"        float d_squared = r.x * r.x + r.y * r.y + (float)1e-10;\n"
"\n"
"        bool is_leaf = (lefts[node] == -1 && rights[node] == -1);\n"
"\n"
"        if ((size * size / d_squared < theta * theta) || is_leaf) {\n"
"            if (d_squared > (float)1e-10) {\n"
"                float2 f = compute_force(my_mass, node_masses[node], my_pos, com[node], G);\n"
"                acc += f / my_mass;\n"
"            }\n"
"            continue;\n"
"        }\n"
"\n"
"        if (rights[node] != -1 && sp+1 < STACK_SIZE) {\n"
"            sp++;\n"
"            stack[sp] = rights[node];\n"
"            sizes[sp] = size * 0.5;\n"
"        }\n"
"        if (lefts[node] != -1 && sp+1 < STACK_SIZE) {\n"
"            sp++;\n"
"            stack[sp] = lefts[node];\n"
"            sizes[sp] = size * 0.5;\n"
"        }\n"
"    }\n"
"\n"
"    acc_out[gid] = acc;\n"
"}\n";

}
}