#pragma once
#include <string>

namespace Aster{
namespace GPU{

inline std::string newton_cl3d = 
"#define WG 256\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"double3 get_force(\n"
"   const double G,\n"
"   const double C,\n"
"   const double  m1,\n"
"   const double  m2,\n"
"   const double3 p1,\n"
"   const double3 p2,\n"
"   const double3 v1,\n"
"   const double3 v2\n"
"){\n"
"   double3 a = (double3)(0.0,0.0,0.0);\n"
"   double3 r = p2 - p1;\n"
"   double d2 = dot(r,r) + 10e-11;\n"
"   double invDist = native_rsqrt(d2);\n"
"   double invDist3 = invDist * invDist * invDist * G;\n" 
"   a += m2 * r * invDist3;\n"
"   return a;"
"}"
"__kernel void newton(\n"
"    const uint    N,\n"
"    const double  G,\n"
"    const double  C,\n"
"    __global const double*   t,\n"
"    __global const double*   m,\n"
"    __global const double3*  pos,\n"
"    __global const double3*  vel,\n"
"    __global       double3*  acc_out)\n"
"{\n"
"    const uint i = get_global_id(0);\n"
"    if (i >= N) return;\n"
"\n"
"    double3 pi = pos[i];\n"
"    double3 ai = (double3)(0.0, 0.0, 0.0);\n"
"\n"
"    __local double3 spos[WG];\n"
"    __local double  sm  [WG];\n"
"\n"
"    for (uint tile = 0; tile < N; tile += WG) {\n"
"        uint lid = get_local_id(0);\n"
"        uint j   = tile + lid;\n"
"\n"
"        if (j < N) {\n"
"            spos[lid] = pos[j];\n"
"            sm  [lid] = m[j];\n"
"        } else {\n"
"            spos[lid] = (double3)(0.0,0.0,0.0);\n"
"            sm  [lid] = 0.0;\n"
"        }\n"

"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        for (int k = 0; k < WG; ++k) {\n"
"            uint global_j = tile + k;\n"
"            if (global_j < N && global_j != i) {\n"
"               ai += get_force(G, C, 1.0, sm[k], pi, spos[k], vel[0], vel[0]);\n"
"            }\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"\n"
"    acc_out[i] = ai;\n"
"}";

inline std::string newton_cl3d_lite = 
"#define WG 256\n"
"__kernel void newton(\n"
"    const uint    N,\n"
"    const float  G,\n"
"    const float  C,\n"
"    __global const float*   t,\n"
"    __global const float*   m,\n"
"    __global const float3*  pos,\n"
"    __global const float3*  vel,\n"
"    __global       float3*  acc_out)\n"
"{\n"
"    const uint i = get_global_id(0);\n"
"    if (i >= N) return;\n"
"\n"
"    float3 pi = pos[i];\n"
"    float3 ai = (float3)(0.0, 0.0, 0.0);\n"
"\n"
"    __local float3 spos[WG];\n"
"    __local float  sm  [WG];\n"
"\n"
"    for (uint tile = 0; tile < N; tile += WG) {\n"
"        uint lid = get_local_id(0);\n"
"        uint j   = tile + lid;\n"
"\n"
"        if (j < N) {\n"
"            spos[lid] = pos[j];\n"
"            sm  [lid] = m[j];\n"
"        } else {\n"
"            spos[lid] = (float3)(0.0,0.0,0.0);\n"
"            sm  [lid] = 0.0;\n"
"        }\n"

"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        for (int k = 0; k < WG; ++k) {\n"
"            uint global_j = tile + k;\n"
"            if (global_j < N && global_j != i) {\n"
"                float3 r = spos[k] - pi;\n"
"                float d2 = dot(r,r) + 10e-11;\n"
"                float invDist = native_rsqrt(d2);\n"
"                float invDist3 = invDist * invDist * invDist * G;\n" 
"                ai += sm[k] * r * invDist3;\n"
"            }\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"\n"
"    acc_out[i] = ai;\n"
"}";

}
}
