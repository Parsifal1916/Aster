#pragma once
#include <string>

namespace Aster{
namespace GPU{

inline std::string barnes_tree_cl = 
"int delta(int num_leaves, const uint2* mortons, int ii, int jj){\n"
"   if (jj >= (int)num_leaves) return -1;\n"
"   uint key_i = mortons[ii].x;\n"
"   uint key_j = mortons[jj].x;\n"
"   if (key_i == key_j) {\n"
"       return 32 + clz((uint)(ii ^ jj));\n"
"   } else {\n"
"       return clz(key_i ^ key_j);\n"
"   }\n"
"}\n"
"__kernel void build_tree(\n"
"             const uint   num_leaves,\n"
"    __global const uint2* mortons,\n"
"    __global       int*   left_nodes,\n"
"    __global       int*   right_nodes\n"
") {\n"
"    uint i = get_global_id(0);\n"
"    uint num_internal = num_leaves - 1;\n"
"    if (i >= num_internal) return;\n"
"\n"
"\n"
"    int d_left  = (i == 0)            ? -1 : delta(num_leaves, mortons, i, i - 1);\n"
"    int d_right = delta(num_leaves, mortons, i, i + 1);\n"
"    int d       = (d_right > d_left) ?  1 : -1;\n"
"    int d_min   = (d == 1) ? d_left : d_right;\n"
"\n"
"    uint l_max = 2;\n"
"    while ((int)(i + l_max * d) >= 0\n"
"        && (int)(i + l_max * d) < (int)num_leaves\n"
"        && delta(num_leaves, mortons, i, i + l_max * d) > d_min) {\n"
"        l_max <<= 1;\n"
"    }\n"
"\n"
"    uint l = 0;\n"
"    for (uint t = l_max >> 1; t >= 1; t >>= 1) {\n"
"        int test_pos = (int)(i + (l + t) * (uint)d);\n"
"        if ( test_pos >= 0\n"
"          && test_pos < (int)num_leaves\n"
"          && delta(num_leaves, mortons, i, test_pos) > d_min ) {\n"
"            l += t;\n"
"        }\n"
"    }\n"
"\n"
"    int j      = (int)(i + l * (uint)d);\n"
"    int d_node = delta(num_leaves, mortons, i, j);\n"
"\n"
"    uint range_size = (j > (int)i) ? j - (int)i : (int)i - j;\n"
"    uint s = 0;\n"
"    for (uint t = (range_size + 1) >> 1; t >= 1; t = (t + 1) >> 1) {\n"
"        int test_pos = (int)(i + (s + t) * (uint)d);\n"
"        if ( test_pos >= 0\n"
"          && test_pos < (int)num_leaves\n"
"          && delta(num_leaves, mortons, i, test_pos) > d_node ) {\n"
"            s += t;\n"
"        }\n"
"        if (t == 1) break;\n"
"    }\n"
"\n"
"    int gamma = (int)(i + s * (uint)d + (d < 0 ? -1 : 0));\n"
"\n"
"    uint internal_node = num_leaves + i;\n"
"    int left_range  = min((int)i, j);\n"
"    int right_range = max((int)i, j);\n"
"\n"
"    if (left_range == gamma) {\n"
"        left_nodes[internal_node]  = gamma;\n"
"    } else {\n"
"        left_nodes[internal_node]  = num_leaves + gamma;\n"
"    }\n"
"    if (right_range == gamma + 1) {\n"
"        right_nodes[internal_node] = gamma + 1;\n"
"    } else {\n"
"        right_nodes[internal_node] = num_leaves + gamma + 1;\n"
"    }\n"
"}\n";

}
}
